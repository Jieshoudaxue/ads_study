按照十步学习法学习 autoware：

1 第一部分 只做一次
1.1 了解全局
（1）autoware：是最早的自动驾驶开源项目（比 apollo 更早），由名古屋大学加藤伸平教授于2015年8月创建，并创建 Autoware 基金会进行维护。2015年12月下旬，加藤伸平教授还创立了Tier IV，目标是将Autoware应用于真正的自动驾驶汽车上。
（2）autoware 使用 ros 作为中间件，与 ros 深度绑定，并先后出过几个版本：基于ROS 1的AutoWare.ai（2022年停更），基于ROS2的AutoWare.auto，后来更进一步升级为 Autoware.core/universe。目前 autoware 主推 .core/.universe 版本。
（3）目前，autoware 在自动驾驶领域与 apollo 齐名，是最流行的两种开源智驾框架，国外 autoware 更火一些。相比 apollo，autoware 更精简，并且由于与 ros 绑定，更容易上手。
（4）autoware 本身是一套完整的自动驾驶体系，包括传感器，感知，定制，规控，高清地图等等算法模块， 也能与 carla（支持ros） 和 LGsvl 两款仿真软件联合仿真，自身也有 AVP（代课泊车）和 cargo （机场物流小车）demo，可以说 autoware 既是理解自动驾驶知识最好的模板，也是锻炼实际工程能力的良好载体。

1.2 和 1.3 确定范围和定义目标
（1）学习最新的 autoware.core/universe，跑通 autoware.universe 的几个 demo，理解智驾数据流。理解 autoware 各个算法模块的代码框架，能基本掌握原理和代码，并能初步对应起来，但不强求精通。
（2）掌握 carla 和 lgsvl 仿真测试知识，会与 autoware 联合仿真。能在仿真环境下对算法进行调试，感受各个算法模块的差别。

1.4 寻找资源
官网传送门: 
    https://www.autoware.org/

autoware github官方主页：
    https://github.com/autowarefoundation/autoware

autoware github官方文档： 
    https://autowarefoundation.github.io/autoware-documentation/main/
autoware 老的gitlab文档地址（2022年以后，autoware搬到github了）
    https://autowarefoundation.gitlab.io/autoware.auto/AutowareAuto/

autoware youtube官方主页：
    https://www.youtube.com/@autowarefoundation

autoware官方视频网站，资料：
    https://www.apex.ai/autoware-course
    https://www.youtube.com/watch?v=XTmlhvlmcf8&list=PLL57Sz4fhxLpCXgN0lvCF7aHAlRA5FoFr
    B站中文翻译版（同youtube）：https://www.bilibili.com/video/BV16p4y1Y7jb/?spm_id_from=333.337.search-card.all.click&vd_source=070cf712cbaef234201f1602115617d7
    https://gitlab.com/ApexAI/autowareclass2020

autoware 的昨天今天明天：
    https://autoware.org/past-present-and-the-future-of-autoware/
    https://autowarefoundation.github.io/autoware-documentation/main/design/autoware-concepts/difference-from-ai-and-auto/

autoware 公告区：
    https://discourse.ros.org/c/autoware/46
autoware 讨论区：
    https://github.com/orgs/autowarefoundation/discussions
autoware 项目区：
    https://github.com/orgs/autowarefoundation/projects?query=is%3Aopen

autoware.ai github主页（2022年停更，目前只读）：
    https://github.com/autowarefoundation/autoware_ai
autoware官方学习仓库：
    https://github.com/tier4/AutowareArchitectureProposal.proj?tab=readme-ov-file

博客资料：
    Autoware 软件开发指南（.ai，非常详细，高质量）：https://github.com/cyhasuka/Autoware-Manuals-Chinese?tab=readme-ov-file#jump4.0
    autoware.auto框架介绍：https://fishros.org.cn/forum/topic/299/autoware-auto%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D
    Autoware.Auto教程：http://lib.uml.com.cn/ebook/Autoware.Auto/Autoware955.asp
    Autoware.auto的安装、配置与测试（Docker版）https://www.guyuehome.com/37552


国内的讲解资料（概况）：
    Autoware_ROS2发展环境课程介绍01: https://blog.csdn.net/qq_37464479/article/details/117729715  
    自动驾驶开源项目Autoware.Auto介绍（重点）：https://www.bilibili.com/video/BV1fb4y1B7Zm/?spm_id_from=333.337.search-card.all.click&vd_source=070cf712cbaef234201f1602115617d7

    
国内的教学资料：
    【全新】自动驾驶框架Autoware源码解析与项目实战（天宇，autoware.ai，付费）：https://cvlife.net/p/t_pc/goods_pc_detail/goods_detail/course_2ZpeirG04cDayEqoY30IPztaBJZ
    Autoware全系列仿真操作指南（只讲解环境搭建，涉及三个版本的autoware，付费）：https://www.bilibili.com/cheese/play/ep487877?query_from=0&search_id=16955594302639449062&search_query=autoware&csource=common_hpsearch_null_null&spm_id_from=333.337.search-card.all.click 


资料思路调整：我要学习的是 autoware.universe，因此不能以老的 autoware.auto 的视频资料为主，应该以 autoware.universe 的文档和代码资料为主
    第一，核心资料四个，
        一是 autoware.universe github：https://github.com/autowarefoundation/autoware 
                                       https://github.com/autowarefoundation/autoware.core 
                                       https://github.com/autowarefoundation/autoware.universe
        二是 autoware doc：https://autowarefoundation.github.io/autoware-documentation/main/ 
        三是 autoware.universe doc ： https://autowarefoundation.github.io/autoware.universe/main/ 
        四是 autoware tools doc: https://autowarefoundation.github.io/autoware_tools/main/
    
    第二，次一点的资料：autoware.universe 视频：https://www.youtube.com/watch?v=xbLBJRSYybY&list=PLuCQPvHJs-PsdRduUGJxPq_FwF63FlB3a   
    
    第二，其他资料，主要是老版本 autoware 的资料：
        youtube autoware.auto 的视频：https://www.youtube.com/playlist?list=PLL57Sz4fhxLpCXgN0lvCF7aHAlRA5FoFr 
        视频对应的文档：https://gitlab.com/ApexAI/autowareclass2020/-/tree/master/lectures?ref_type=heads 
        
        autoware.auto 老的文档：https://autowarefoundation.gitlab.io/autoware.auto/AutowareAuto/
        国内的翻译版：http://lib.uml.com.cn/ebook/Autoware.Auto/Autoware955.asp
        autoware.auto框架介绍：https://fishros.org.cn/forum/topic/299/autoware-auto%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D
        
        国内 autoware.ai 总结资料：https://github.com/cyhasuka/Autoware-Manuals-Chinese?tab=readme-ov-file#jump4.0
        国内 autoware.ai 卖课资料（可以借鉴目录）：https://cvlife.net/p/t_pc/goods_pc_detail/goods_detail/course_2ZpeirG04cDayEqoY30IPztaBJZ


    
1.5和1.6 创建学习计划和筛选资料
（1）autoware 引入，智驾技术架构介绍，源码安装，智驾安全性介绍，智驾实时性讨论
    https://autowarefoundation.github.io/autoware-documentation/main/
    https://github.com/autowarefoundation/autoware 
    https://autowarefoundation.github.io/autoware-documentation/main/design/autoware-concepts/
    https://autowarefoundation.github.io/autoware-documentation/main/design/autoware-concepts/difference-from-ai-and-auto/
    https://autowarefoundation.github.io/autoware-documentation/main/design/autoware-architecture/

    https://autowarefoundation.github.io/autoware-documentation/main/installation/

（2）autoware.universe 仿真测试

    https://autowarefoundation.github.io/autoware-documentation/main/tutorials/

    Autoware.Universe：如何在Carla 0.9.13上运行:
    https://www.bilibili.com/read/cv19814487/

    CARLA - Autoware universe Tutorial 2:
    https://www.youtube.com/watch?v=dxwwNacez7o
    https://www.youtube.com/watch?v=dxwwNacez7o


（3）开发自己的 autoware.universe，并使用 awsim 进行仿真
    https://autowarefoundation.github.io/autoware-documentation/main/how-to-guides/
    https://tier4.github.io/AWSIM/
    
（4）autoware.universe 各模块的架构和接口设计：传感器，地图，定位，感知，规划，控制，车辆
    https://autowarefoundation.github.io/autoware-documentation/main/design/
    https://autowarefoundation.github.io/autoware-documentation/main/design/autoware-architecture/node-diagram/
    https://autowarefoundation.github.io/autoware.universe/main/ 

    autoware.universe源码略读： https://blog.csdn.net/weixin_45432823/category_12681689.html



2 第二部分--在各个知识模块循环往复

2.1 autoware 引入，智驾技术架构介绍，智驾安全性介绍，智驾实时性讨论
    第一篇：鸟瞰 autoware：https://blog.csdn.net/cy1641395022/article/details/139936282
    第二篇，在 ubuntu22.04 + ros2 humble 安装 autoware.universe：https://blog.csdn.net/cy1641395022/article/details/140232957
    第三篇，智驾技术务虚会之智驾技术栈讨论：https://blog.csdn.net/cy1641395022/article/details/140278524
    第四篇，智驾技术务虚会之智驾安全性讨论：https://blog.csdn.net/cy1641395022/article/details/140332393





    第五篇博客，智驾系统实时性介绍，包括内核实时，dds实时，节点开发实时。修复之前 dds 博客的误区
        https://gitlab.com/ApexAI/autowareclass2020/-/blob/master/lectures/04_Platform/ECUandRTOS.pdf?ref_type=heads
        总结：第一课主要讲解了智驾汽车的电子软硬件，包括各种ECU，RTOS，特别强调了实时系统 real-time os，核心点是确定性（不要与高速混淆）：确定时间完成确定任务，有效控制最大延迟，os调度器主要采用 Pre-emptive（可抢占式）（补充：TSN交换机的核心也是抢占式包调度机制，确保传播延迟确定）。下面有个样例，可以尝试运行一下，感受实时系统和非实时系统的区别，了解如何把普通桌面linux改为实时系统（通过打RT_PREEMPT内核补丁）。另外，还提到了软实时和硬实时的概念，需要进一步了解。

        
        TODO1：测试并实现下面的钟摆样例，感受 real-time os 和 普通系统的区别，并总结实时系统的编程套路，出一篇智驾C++开发如何实现实时效果的博客，如果能结合 DDS 实现，效果最佳。
            ros2 的实时性讨论以及实时系统的定义和实现方式：
                https://docs.ros.org/en/humble/Tutorials/Demos/Real-Time-Programming.html
                https://design.ros2.org/articles/realtime_background.html

        TODO2：写完实时系统博客之后，对之前 ros2 dds的文章进行优化，之前的文章确实混淆了实时和高速的概念
            ros2 DDS两篇：
                https://blog.csdn.net/cy1641395022/article/details/135261069
                https://blog.csdn.net/cy1641395022/article/details/136202639

            
            
            
            
            
        ros2 原生倒立摆及其用法：
            https://github.com/ros2/demos/tree/master/pendulum_control
            https://docs.ros.org/en/humble/Tutorials/Demos/Real-Time-Programming.html



        倒摆演示：https://www.youtube.com/watch?v=MWJHcI7UcuE

        倒立摆：
            一级倒立摆控制 —— ROS2 仿真：
            https://blog.csdn.net/ZhangRelay/article/details/103688353        
            https://blog.csdn.net/weixin_46300916/article/details/133949315
            
            一级倒立摆控制 —— PID 控制器设计及 MATLAB 实现：
            https://blog.csdn.net/weixin_46300916/article/details/133877366
            
            https://github.com/ros2-realtime-demo/pendulum.git
            https://github.com/Jieshoudaxue/pendulum/blob/rolling/docs/tutorial.md
            
            https://github.com/Jieshoudaxue/pendulum/blob/rolling/docs/design.md
            https://design.ros2.org/articles/node_lifecycle.html
            
            下面两篇是同一作者，主题也一样，只是一个是文章，另一个是ppt（应对照学习）：
            https://design.ros2.org/articles/realtime_background.html
            E:\智能汽车学习\ads_study\ads doc\RealtimeROS2
            
            https://www.ni.com/zh-cn/shop/data-acquisition-and-control/add-ons-for-data-acquisition-and-control/what-is-labview-real-time-module/what-is-a-real-time-operating-system--rtos--.html
            https://en.wikipedia.org/wiki/Full_state_feedback

            编译命令：
            colcon build --packages-select pendulum pendulum2_msgs pendulum_utils pendulum_controller pendulum_driver pendulum_state_publisher pendulum_demo pendulum_bringup

            运行倒立摆（rviz可视化查看）：
            source install/local_setup.bash
            ros2 launch pendulum_bringup pendulum_bringup.launch.py rviz:=True

            移动小车：
            ros2 topic pub -1 /teleop pendulum2_msgs/msg/PendulumTeleop "cart_position: 5.0"
            
            
            ros2 run topic_tools relay /parameter_events /parameter_events_fake



            编译踩坑1：
            ycao@ycao:~/ros2_ads/code_space$ colcon build --packages-select pendulum_driver
            Starting >>> pendulum_driver
            --- stderr: pendulum_driver
            CMake Error at CMakeLists.txt:59 (find_package):
              By not providing "Findapex_test_tools.cmake" in CMAKE_MODULE_PATH this
              project has asked CMake to find a package configuration file provided by
              "apex_test_tools", but CMake did not find one.

              Could not find a package configuration file provided by "apex_test_tools"
              with any of the following names:

                apex_test_toolsConfig.cmake
                apex_test_tools-config.cmake

              Add the installation prefix of "apex_test_tools" to CMAKE_PREFIX_PATH or
              set "apex_test_tools_DIR" to a directory containing one of the above files.
              If "apex_test_tools" provides a separate development package or SDK, be
              sure it has been installed.


            ---
            Failed   <<< pendulum_driver [0.53s, exited with code 1]

            解决：缺少 apex_test_tools 包，可以使用 rosdep 统一安装 pendulum 的所有依赖
            # rosdep 工具，它是ROS的一个强大命令行工具，用于帮助安装软件包的依赖项
            rosdep install -q -y --from-paths src --ignore-src --rosdistro humble







        RT_PREEMPT内核补丁介绍：
            RT_PREEMPT 是 Linux 内核的一个变体，它通过一系列的补丁被实时化（real-time）了。这些补丁是为了减少内核中不可抢占的代码路径的数量和持续时间，使得内核能够以更可预测的方式来响应实时任务的需求。

            在标准的 Linux 内核中，有很多执行路径是不可抢占的，尤其是在内核模式下。这意味着当内核正在处理某些事务时，无法被高优先级的任务打断。对于大多数桌面和服务器应用来说，这种设计是可接受的，因为它简化了内核设计，并且提供了足够的性能。

            然而，在需要严格的实时性能的系统中，例如工业控制、机器人或者嵌入式设备，这些不可抢占的执行路径可能会导致无法接受的延迟。实时系统要求能够在非常短的、确定的时间内响应外部事件。RT_PREEMPT 补丁就是为了解决这个问题而产生的。

            以下是 RT_PREEMPT 补丁所实现的主要特性：

            抢占式内核: 允许内核代码（除了那些关键区段）被抢占。
            高分辨率定时器: 支持更精确的定时功能。
            优先级继承: 防止优先级反转的问题，即低优先级任务阻塞高优先级任务的执行。
            改进的中断管理: 使得中断处理对实时性能的影响最小化。
            改进的锁机制: 引入自旋锁替代品，如睡眠锁，减少等待锁时的CPU时间浪费。
            使用 RT_PREEMPT 补丁的 Linux 内核通常被称为“实时内核”（Real-Time Kernel）。开发者可以从 kernel.org 或者实时补丁的维护者那里获取这些补丁，并将其应用到特定版本的内核源码中，以构建自己的实时内核。需要注意的是，实时内核可能需要更认真地考虑系统的调优和配置，以确保达到所需的实时性能标准。

        
        软实时和硬实时区别（简单概况为：桌面linux就是软实时，rtos，比如qnx，就是硬实时。软实时就是尽可能实时，实在不行也没事；硬实时是确定实时，由软硬件综合保证（调度策略等等））：
            软实时操作系统 (Soft Real-time OS) 和 硬实时操作系统 (Hard Real-time OS) 的区别主要在于它们对于实时性能的保证程度。以下是两者之间一些关键的区别：

            软实时操作系统 (Soft Real-time OS)
            实时性目标: 在这种系统中，实时任务通常有较高的优先级，但并不保证一定能在严格的时间限制内完成。如果偶尔违反时间约束，系统仍然可接受，并不会导致灾难性后果。

            应用场景: 适用于那些对时间敏感度较低的应用，比如多媒体播放、网络通信等。在这些应用中，偶尔的延迟或性能下降通常不会造成重大问题。

            容错性: 相较于硬实时系统，软实时系统对任务执行的准时性要求不那么严格，因此具有更大的容错空间。

            调度策略: 采用柔性的任务调度策略，可能包括动态优先级调整。即使某些实时任务延迟，系统也能继续运行而不会出现严重故障。

            硬实时操作系统 (Hard Real-time OS)
            实时性目标: 这类系统提供严格的时间保证。每个实时任务都必须在规定的时间截止前完成，否则可能导致系统功能故障甚至危及人身安全。

            应用场景: 适用于高度依赖时间精度的关键性任务，如航空控制系统、工业自动化控制、医疗设备等。在这些领域，任何时间上的违规都可能产生不可预知的严重后果。

            容错性: 几乎没有容错余地。系统设计必须确保所有实时任务在预定时间内完成。

            调度策略: 通常采用固定的、可预测的任务调度机制，比如速率单调调度(Rate Monotonic Scheduling)和最早截止时间优先(Earliest Deadline First)。

            总结来说，硬实时操作系统与软实时操作系统的主要区别在于对实时性的保证程度。硬实时系统需要严格遵循时间约束，而软实时系统可以在一定程度上容忍时间上的偏差。    













































